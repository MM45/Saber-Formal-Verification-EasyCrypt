pragma Goals:printall.

(*
----------------------------------- 
 Require/Import EasyCrypt Theories
-----------------------------------
*)
(* --- Built-in --- *)
require import AllCore List Ring Bigalg StdBigop StdOrder IntDiv ZModP.
require (*--*) Subtype.
(*---*) import Bigint IntID IntOrder.

(*
----------------------------------- 
 Saber's Polynomial Quotient Rings
-----------------------------------
*)

const p : { int | 2 <= p } as ge2_coeffp.

const en : { int | 0 <= en } as ge0_en. 
const n : int = 2 ^ en.

lemma ge1_n: 1 <= n by rewrite exprn_ege1; first apply ge0_en.

type coeff.
type poly.

clone import ZModRing as Coeff with
    op p <- p,
    type zmod <- coeff
  proof ge2_p by apply ge2_coeffp.

clone import BigComRing as BigCf with
    type t <- coeff,
    pred CR.unit <- Coeff.unit,
    op CR.zeror <- Coeff.zero,
    op CR.oner <- Coeff.one,
    op CR.( + ) <- Coeff.( + ),
    op CR.([-]) <- Coeff.([-]),
    op CR.( * ) <- Coeff.( * ),
    op CR.invr <- Coeff.inv,
    op CR.intmul <- Coeff.ZModpRing.intmul,
    op CR.ofint <- Coeff.ZModpRing.ofint,
    op CR.exp <- Coeff.ZModpRing.exp
  proof CR.addrA by apply Coeff.ZModpRing.addrA
  proof CR.addrC by apply Coeff.ZModpRing.addrC
  proof CR.add0r by apply Coeff.ZModpRing.add0r
  proof CR.addNr by apply Coeff.ZModpRing.addNr
  proof CR.oner_neq0 by apply Coeff.ZModpRing.oner_neq0
  proof CR.mulrA by apply Coeff.ZModpRing.mulrA
  proof CR.mulrC by apply Coeff.ZModpRing.mulrC
  proof CR.mul1r by apply Coeff.ZModpRing.mul1r
  proof CR.mulrDl by apply Coeff.ZModpRing.mulrDl
  proof CR.mulVr by apply Coeff.ZModpRing.mulVr
  proof CR.unitP by apply Coeff.ZModpRing.unitP
  proof CR.unitout by apply Coeff.ZModpRing.unitout

  rename [theory] "BAdd" as "BCA"
         [theory] "BMul" as "BCM"

  remove abbrev CR.(-)
  remove abbrev CR.(/).

(* ---------------------------------------------------------------------------------------------- *)
type prepoly = int -> coeff.

inductive ispoly (p : prepoly) =
| IsPoly of
      (forall c, c < 0 => p c = zero)
    & (exists d, d < n /\ forall c, (d < c) => p c = zero).

clone include Subtype with 
    type T   <- prepoly,
    type sT  <- poly,
    pred P   <- ispoly,
    op wsT <- (fun _ => zero)
  rename "insub" as "to_poly"
  rename "val"   as "of_poly".

op "_.[_]" (p : poly) (i : int) = (of_poly p) i.

lemma lt0_coeff (p : poly) (c : int) : c < 0 => p.[c] = zero.
proof.
  by move=> lt0_c; rewrite /"_.[_]"; case: (of_polyP p) => /(_ _ lt0_c).
qed.

op deg (p : poly) = argmin idfun (fun (i : int) => forall (j : int), (i <= j) => p.[j] = zero).

lemma ge0_deg (p : poly) : 0 <= deg p.
proof. rewrite /deg &(ge0_argmin). qed.

lemma gedeg_coeff (p : poly) (c : int) : deg p <= c => p.[c] = zero.
proof.
  move=> le_p_c; pose P p i := forall j, (i <= j)%Int => p.[j] = zero.
  case: (of_polyP p) => [wf_p [d hd]]; move: hd; case => gtd_n pc0; move: (argminP idfun (P p)).
  move/(_ (max (d+1) 0) _ _) => @/P @/idfun /=; first exact: maxrr.
  - by move=> j le_d_j; apply: pc0 => /#.
  by apply; apply: le_p_c.
qed.

lemma gedeg_coeff_contra (p : poly) (c : int) : p.[c] <> zero => c < deg p.
proof. move: (gedeg_coeff p c); rewrite lerNgt; apply (contraR (c < deg p) (p.[c] = zero)). qed.

lemma len_deg (p : poly) : deg p <= n.
proof. 
  rewrite /deg; case: (of_polyP p) => [wf_p [d hd]]; move: hd; case => gtd_n pc0.
  pose P (i : int) := forall (j : int), (i <= j) => p.[j] = zero.
  have minz_maxd10: P (idfun (max (d + 1) 0)); 1: rewrite /idfun /max /P => j. 
  case (d + 1 < 0) => [lt0_d1 ge0_j | gt0_d1 ged1_j]; move: (pc0 j); have ->: d < j; 2, 4: trivial.
   by apply /(ltr_le_trans 0) /ge0_j /(ltz_trans (d + 1)) /lt0_d1; rewrite (ltz_addl d 1). 
   by rewrite addzC lez_add1r in ged1_j.
  have learg_maxd10: argmin idfun P <= max (d + 1) 0.
   move: (argmin_min idfun P (max (d + 1) 0)) => amin. 
    apply (contraL (0 <= max (d + 1) 0 && max (d + 1) 0 < argmin idfun P) (P (idfun (max (d + 1) 0)))) in amin.
    rewrite minz_maxd10 /= andabP negb_and -ltzNge -lezNgt in amin.
   move: amin; case; by rewrite // ltzNge maxrr.
  apply /(lez_trans (max (d + 1) 0) _ _ learg_maxd10); rewrite ler_maxrP; split.
   by rewrite addzC lez_add1r. 
   by apply /(lez_trans 1) /ge1_n.     
qed.

lemma len_maxdegs (p q : poly) : max (deg p) (deg q) <= n.
proof. by rewrite /max; case (deg p < deg q) => ?; apply len_deg. qed.

lemma ltn_maxdegs1 (p q : poly) : max (deg p) (deg q) - 1 < n.
proof. by rewrite -(lez_add1r) addzC /= len_maxdegs. qed. 

lemma ge0_maxdegs (p q : poly) : 0 <= max (deg p) (deg q).
proof. by rewrite /max; case (deg p < deg q) => ?; apply ge0_deg. qed.

op prepolyC  (c   : coeff) = fun i => if i = 0 then c else zero.
op prepolyXn (k   : int  ) = fun i => if 0 <= k /\ k < n /\ i = k then one else zero.
op prepolyD  (p q : poly ) = fun i => p.[i] + q.[i].
op prepolyN  (p   : poly ) = fun i => - p.[i].

op prepolyM (p q : poly) = fun (k : int) =>
  if 0 <= k /\ k < n
  then BCA.bigi predT (fun (i : int) => p.[i] * q.[k - i] - p.[i] * q.[n + k - i]) 0 n
  else zero.

op prepolyZ (z : coeff) (p : poly) = fun k =>
  z * p.[k].

lemma ispolyC (c : coeff) : ispoly (prepolyC c).
proof.
  split => @/prepolyC [c' ?|]; 1: by rewrite ltr_eqF.
   exists 0; split; 1: by apply /(ltr_le_trans 1) /ge1_n. 
    by move => c' gt1_c'; rewrite gtr_eqF.
qed.

lemma ispolyXn (k : int) : ispoly (prepolyXn k).
proof.
  split => @/prepolyXn [c lt0_c|].
   by case: (0 <= k) => //= ge0_k; rewrite ltr_eqF //#.
   case: (k < n) => krel; first exists k; split; 1: by apply krel.
    by move => c; rewrite ltz_def -neqF; case => neq_ck ?; rewrite neq_ck. 
    by exists (n - 1); split; 1: rewrite -(ltz_add2r 1) /= (ltz_addl n).
qed.

lemma ispolyN (p : poly) : ispoly (prepolyN p).
proof.
  split => @/prepolyN [c lt0_c|]; 1: by rewrite ZModpRing.oppr_eq0 lt0_coeff.
   exists (deg p - 1); split; 1: by apply /(ltr_le_trans (deg p)) /len_deg;
          rewrite -(ltz_add2r 1) /= (ltz_addl).  
    by move => c ltdegp1_c; rewrite -lez_add1r addzC /= in ltdegp1_c; 
       rewrite ZModpRing.oppr_eq0 gedeg_coeff.
qed.

lemma ispolyD (p q : poly) : ispoly (prepolyD p q).
proof.
  split=> @/prepolyD [c lt0_c|]; 1: by rewrite !lt0_coeff // ZModpRing.addr0. 
  exists (max (deg p) (deg q) - 1); split; 1: apply ltn_maxdegs1; move => c.
   by rewrite /max; case (deg p < deg q) => deg_rel ltc_deg1; 
           have: (p.[c] = zero /\ q.[c] = zero); 
           [| by case => p0 q0; rewrite p0 q0 ZModule.add0r | | by case => p0 q0; rewrite p0 q0 ZModule.add0r];
           split; rewrite gedeg_coeff //=; rewrite -lez_add1r addzC /= in ltc_deg1;
           [apply /ltzW /(ltr_le_trans (deg q)) | | | rewrite -lezNgt in deg_rel;apply (lez_trans (deg p))]. 
qed.

lemma ispolyM (p q : poly) : ispoly (prepolyM p q).
proof.
  split => @/prepolyM [c lt0_c|]; 1: by rewrite ltzNge -neqF in lt0_c; rewrite lt0_c //=.
   exists (n - 1); split; 1: by rewrite -(ltz_add2r 1) /= ltz_addl.
    move => c; rewrite -(lez_add1r) addzC /= => lec_n. 
     by move: (lez_lt_asym n c); rewrite andabP negb_and -(implyNb) lec_n /= -neqF => cnf; rewrite cnf //=.
qed.

lemma ispolyZ z p : ispoly (prepolyZ z p).
proof.  
  by split => @/prepolyZ [c lt0_c|]; 
           [| exists (deg p - 1); split; [rewrite -lez_add1r addzC /= len_deg | move => c ltc]]; 
           rewrite /( * ) -eq_inzmod mod0z; have ->: asint z * asint p.[c] = 0; 
           [| apply mod0z | | apply mod0z]; rewrite mulf_eq0 -zeroE (asint_eq (p.[c])); right; 
           [apply lt0_coeff | apply gedeg_coeff; rewrite -lez_add1r addzC /= in ltc]. 
qed.

lemma poly_eqP (p q : poly) : p = q <=> (forall c, 0 <= c => c < n => p.[c] = q.[c]).
proof.
  split=> [->//|eq_coeff]; apply/of_poly_inj/fun_ext => c.
  case: (c < 0 \/ n <= c); [case => [lt0_c | gen_c] | by rewrite negb_or -ltzNge -lezNgt; case; apply eq_coeff]. 
   by rewrite -/"_.[_]" !lt0_coeff.
   by rewrite -/"_.[_]" !gedeg_coeff; 1, 2: apply /(lez_trans n); 1, 3: apply len_deg.
qed.

op polyC  c   = to_polyd (prepolyC  c).
op polyXn k   = to_polyd (prepolyXn k).
op polyN  p   = to_polyd (prepolyN  p).
op polyD  p q = to_polyd (prepolyD  p q).
op polyM  p q = to_polyd (prepolyM p q).
op polyZ  z p = to_polyd (prepolyZ z p).

abbrev poly0  = polyC  zero.
abbrev poly1  = polyC  one.
abbrev polyX  = polyXn 1.
abbrev X      = polyXn 1.
abbrev ( + )  = polyD.
abbrev [ - ]  = polyN.
abbrev ( - )  = fun p q => p + (-q).
abbrev ( * )  = polyM.
abbrev ( ** ) = polyZ.

(* -------------------------------------------------------------------- *)
lemma coeffE p k : ispoly p => (to_polyd p).[k] = p k.
proof. by move=> ?; rewrite /"_.[_]" to_polydK. qed.

lemma polyCE c k : (polyC c).[k] = if k = 0 then c else zero.
proof. by rewrite coeffE 1:ispolyC. qed.

lemma poly0E k : poly0.[k] = zero.
proof. by rewrite polyCE if_same. qed.

lemma polyNE p k : (-p).[k] = - p.[k].
proof. by rewrite coeffE 1:ispolyN. qed.

lemma polyDE p q k : (p + q).[k] = p.[k] + q.[k].
proof. by rewrite coeffE 1:ispolyD. qed.

lemma polyME p q k : (p * q).[k] =
  if 0 <= k /\ k < n
  then BCA.bigi predT (fun (i : int) => p.[i] * q.[k - i] - p.[i] * q.[n + k - i]) 0 n
  else zero.
proof. by rewrite coeffE 1:ispolyM. qed.

lemma polyZE z p k : (z ** p).[k] = z * p.[k].
proof. by rewrite coeffE 1:ispolyZ. qed.

hint rewrite coeffpE : poly0E polyDE polyNE polyME polyZE.

(* -------------------------------------------------------------------- *)
lemma degP p c :
     0 < c
  => p.[c-1] <> zero
  => (forall i, c <= i => p.[i] = zero)
  => deg p = c.
proof.
  move=> ge0_c nz_p_cB1 degc @/deg; apply: argmin_eq => @/idfun /=.
  - by apply/ltrW. 
  - by apply: degc.
  move=> j [ge0_j lt_jc]; rewrite negb_forall /=.
  by exists (c-1); apply/negP => /(_ _); first by move=> /#.
qed.

(* -------------------------------------------------------------------- *)
lemma degC c : deg (polyC c) = if c = zero then 0 else 1.
proof.
  case: (c = zero) => [->|nz_c]; last first.
  - apply: degP => //=; first by rewrite polyCE.
   by move=> i ge1_i; rewrite polyCE gtr_eqF //#.
  rewrite /deg; apply: argmin_eq => @/idfun //=.
  - by move=> j _; rewrite poly0E.
  - by move=> j; apply: contraL => _ /#.
qed.

lemma degC_le c : deg (polyC c) <= 1.
proof. by rewrite degC; case: (c = zero). qed.

lemma deg0 : deg poly0 = 0.
proof. by rewrite degC. qed.

lemma deg1 : deg poly1 = 1.
proof.
  apply: degP => //=; first by rewrite polyCE /= ZModpRing.oner_neq0.
  by move=> c ge1_c; rewrite polyCE gtr_eqF //#.
qed.

lemma deg_eq0 p : (deg p = 0) <=> (p = poly0).
proof.
  split=> [z_degp|->]; last by rewrite deg0.
  apply/poly_eqP=> c ge0_c ltn_c; rewrite poly0E.
  by apply/gedeg_coeff; rewrite z_degp.
qed.

lemma deg_eq1 p : (deg p = 1) <=> (exists c, c <> zero /\ p = polyC c).
proof.
  split=> [eq1_degp|[c [nz_c ->>]]]; last first.
  + by apply: degP => //= => [|i ge1_i]; rewrite polyCE //= gtr_eqF /#.
  have pC: forall i, 1 <= i => p.[i] = zero.
  + by move=> i ge1_i; apply: gedeg_coeff; rewrite eq1_degp.
  exists p.[0]; split; last first.
  + apply/poly_eqP => c /ler_eqVlt -[<<-|]; first by rewrite polyCE.
    by move=> gt0_c ltn_c; rewrite polyCE gtr_eqF //= &(pC) /#.
  apply: contraL eq1_degp => z_p0; suff ->: p = poly0 by rewrite deg0.
  apply/poly_eqP=> c; rewrite poly0E => /ler_eqVlt [<<-//|].
  by move=> gt0_c ltn_c; apply: pC => /#.
qed.

lemma coeff_degB1_neq0 p : p <> poly0 => p.[deg p - 1] <> zero.
proof.
  rewrite -deg_eq0 eqr_le ge0_deg /= -ltrNge => gt0_deg.
  pose P i := forall j, (i <= j)%Int => p.[j] = zero.
  apply/negP => zp; have := argmin_min idfun P (deg p - 1) _; 1: smt().
  move=> @/idfun /= j /ler_eqVlt [<<-//| ltj].
  by apply: gedeg_coeff => /#.
qed.

(* -------------------------------------------------------------------- *)
clone import Ring.ZModule as ZPoly with
    type t <- poly,
    op zeror <- poly0,
    op (+) <- polyD,
    op [-] <- polyN
  proof *.

  realize addrA.
  proof. by move=> p q r; apply/poly_eqP=> c; rewrite !coeffpE ZModpRing.addrA. qed.

  realize addrC.
  proof. by move=> p q; apply/poly_eqP=> c; rewrite !coeffpE ZModpRing.addrC. qed.

  realize add0r.
  proof. by move=> p; apply/poly_eqP => c; rewrite !coeffpE ZModpRing.add0r. qed.

  realize addNr.
  proof. by move=> p; apply/poly_eqP => c; rewrite !coeffpE ZModpRing.addNr. qed.

(*
lemma polyMEw M p q k : (k <= M)%Int => (p * q).[k] =
  BCA.bigi predT (fun i => p.[i] * q.[k-i]) 0 (M+1).
proof. 
  move=> le_kM; case: (k < 0) => [lt0_k|/lerNgt ge0_k].
   rewrite lt0_coeff // BCA.big_seq BCA.big1 //= => i.
    case/mem_range=> [ge0_i lt_iM]; rewrite /( * ) -eq_inzmod mod0z.
    have ->: asint p.[i] * asint q.[k - i] = 0; [rewrite mulf_eq0 -zeroE; right | by apply mod0z].
     rewrite (asint_eq q.[k - i]) lt0_coeff //.
     by apply /(ler_lt_trans k) /lt0_k /(lez_add2r i); rewrite -addzA /= (lez_addl k).
  rewrite (@BCA.big_cat_int n) 1,2:/# -polyME.
  rewrite BCA.big_seq BCA.big1 2:ZModpRing.addr0 //= => i /mem_range.
  case=> [lt_ki lt_iM]; rewrite /( * ) -eq_inzmod mod0z.
    have ->: asint p.[i] * asint q.[k - i] = 0; [rewrite mulf_eq0 -zeroE; right | by apply mod0z].
     by rewrite (asint_eq q.[k - i]) lt0_coeff // -(ltz_add2r i) -addzA /= -lez_add1r addzC.
qed.
*)

lemma polyMS (p q : poly) (k : int) : (p * q).[k] =
  if (0 <= k /\ k < n)
  then BCA.bigi predT (fun i => p.[i] * q.[k - i]) 0 (k + 1) + 
       BCA.bigi predT (fun i => - (p.[i] * q.[n + k - i])) (k + 1) n
  else zero.
proof.
  pose F1 i := p.[i] * q.[k - i]; pose F2 i := - (p.[i] * q.[n + k - i]).
  pose F i := F1 i + F2 i.
  rewrite polyME; case (0 <= k /\ k < n) => [ [ge0_k ltn_k] | //].
   have <-: F = fun (i : int) => (p.[i] * q.[k - i] - p.[i] * q.[n + k - i]).
    by rewrite fun_ext /(==) /F /F1 /F2 => x.
   rewrite (BCA.big_split predT F1 F2 (range 0 n)) (BCA.big_cat_int (k + 1) 0 n _ F1) 
            3: (BCA.big_cat_int (k + 1) 0 n _ F2);
            [by apply /(lez_trans k); 2: rewrite lez_addl | by rewrite addzC lez_add1r |
             by apply /(lez_trans k); 2: rewrite lez_addl | by rewrite addzC lez_add1r |].

   have ->: (BCA.bigi predT F1 (k + 1) n) = zero.
    rewrite BCA.big_int BCA.big1 //= => i; case => gek1_i ltn_i.
    rewrite /F1 /( * ) -eq_inzmod mod0z.
    have ->: asint p.[i] * asint q.[k - i] = 0; 2: by apply mod0z.
     apply mulf_eq0; right.
      by rewrite -zeroE asint_eq lt0_coeff // subz_lt0; rewrite addzC lez_add1r in gek1_i.
      
   have ->: (BCA.bigi predT F2 0 (k + 1)) = zero.    
    rewrite BCA.big_int BCA.big1 //= => i; case => ge0_i ltk1_i.
    rewrite /F2 /( * ) ZModpRing.oppr_eq0 -eq_inzmod mod0z.
    have ->: asint p.[i] * asint q.[n + k - i] = 0; 2: by apply mod0z.
     apply mulf_eq0; right.
       by rewrite -zeroE asint_eq gedeg_coeff // (lez_trans n) 1:len_deg -(lez_add2r i) -addzA /= lez_add2l;
                  rewrite-lez_add1r {1}addzC -(lez_add2r (-1)) /= in ltk1_i.              
   
   by rewrite -ZModpRing.addrA 2!ZModpRing.add0r.
qed.

lemma mulpC : commutative ( * ).
proof.
  move=> p q; apply: poly_eqP => k ge0_k ltn_k; rewrite !polyMS ge0_k ltn_k /=.
  pose F1 i := p.[i] * q.[k - i]; pose F2 i :=  - (p.[i] * q.[n + k - i]).
  pose F1' i := q.[i] * p.[k - i]; pose F2' i :=  - (q.[i] * p.[n + k - i]).
  pose F i := F1 i + F2 i; pose F' i := F1' i + F2' i.
  pose K j := k - j; pose NK j := n + k - j.
  rewrite (@BCA.big_reindex predT F1 K K) 1:/# (@BCA.big_reindex predT F2 NK NK) 1:/#.
  rewrite (predT_comp K) (predT_comp NK) /(\o) /=. 
  pose s1 := map _ _; pose s2 := map _ _. 
  have ->: BCA.big predT (fun (x : int) => F1 (K x)) s1 = BCA.bigi predT F1' 0 (k + 1).
  apply: (eq_trans _ _ _ (BCA.eq_big_perm _ _ _ (range 0 (k + 1)) _)).
   rewrite uniq_perm_eq 2:&(range_uniq) /s.
    rewrite map_inj_in_uniq 2:&(range_uniq) => x y.
     by rewrite !mem_range /K /#.
     move=> x; split => [/mapP[y []]|]; 1: rewrite !mem_range /#.
     rewrite !mem_range => *; apply/mapP; exists (K x).
     by rewrite !mem_range /K /#.
   apply: BCA.eq_bigr => /= i _ @/K @/F1 @/F1'; rewrite ZModpRing.mulrC /#.
  have ->: BCA.big predT (fun (x : int) => F2 (NK x)) s2 = BCA.bigi predT F2' (k + 1) n; 2: by reflexivity.
   apply: (eq_trans _ _ _ (BCA.eq_big_perm _ _ _ (range (k + 1) n) _)).
    rewrite uniq_perm_eq 2:&(range_uniq) /s.
     rewrite map_inj_in_uniq 2:&(range_uniq) => x y.
      by rewrite !mem_range /NK /#.
     move=> x; split => [/mapP[y []]|]; 1: rewrite !mem_range /#.
      rewrite !mem_range => *; apply/mapP; exists (NK x).
      by rewrite !mem_range /NK /#.
   apply: BCA.eq_bigr => /= i _ @/NK @/F2 @/F2'; rewrite ZModpRing.mulrC /#.
qed.

(*
lemma polyMEwr M p q k : (k <= M)%Int => (p * q).[k] =
  BCA.bigi predT (fun i => p.[k-i] * q.[i]) 0 (M+1).
proof.
  rewrite mulpC => /polyMEw ->; apply: BCA.eq_bigr.
  by move=> i _ /=; rewrite  ZModpRing.mulrC.
qed.
*)
print polyME.

lemma polyMEr (p q : poly) (k : int) : (p * q).[k] =
  if 0 <= k /\ k < n 
  then (BCA.bigi predT (fun (i : int) => (p.[k - i] * q.[i] - p.[n + k - i] * q.[i])) 0 n)
  else zero.
proof. 
  rewrite mulpC !polyME; case (0 <= k /\ k < n) => [[gt0_k ltn_k] | //].
  apply BCA.eq_big_int => i /=; case => ge0_i ltn_i; rewrite /#.
qed.  

lemma polyMSr (p q : poly) (k : int) : (p * q).[k] =
  if (0 <= k /\ k < n)
  then BCA.bigi predT (fun i => p.[k - i] * q.[i]) 0 (k + 1) + 
       BCA.bigi predT (fun i => - (p.[n + k - i] * q.[i])) (k + 1) n
  else zero.
proof. 
  rewrite mulpC !polyMS; case (0 <= k /\ k < n) => [[gt0_k ltn_k] | //].
   have ->: (BCA.bigi predT (fun (i : int) => q.[i] * p.[k - i]) 0 (k + 1)) =
            (BCA.bigi predT (fun (i : int) => p.[k - i] * q.[i]) 0 (k + 1)).
    apply BCA.eq_big_int => i /=; case => ge0_i ltn_i; rewrite /#.
   have ->: (BCA.bigi predT (fun (i : int) => - q.[i] * p.[n + k - i]) (k + 1) n) =
            (BCA.bigi predT (fun (i : int) => - p.[n + k - i] * q.[i]) (k + 1) n).
    apply BCA.eq_big_int => i /=; case => ge0_i ltn_i; rewrite /#.
  by reflexivity.
qed.  


lemma mulpA : associative ( * ).
proof.
  move=> p q r; apply: poly_eqP => k ge0_k ltn_k.
  have ->: ((p * q) * r).[k] =
            if 0 <= k /\ k < n
            then (BCA.bigi predT (fun (i : int) => 
                  (BCA.bigi predT (fun (j : int) => p.[j] * q.[k - i - j] * r.[i]) 0 (k - i + 1))
                  +
                  (BCA.bigi predT (fun (j : int) => - p.[j] * q.[n + k - i - j] * r.[i]) (k - i + 1) n))
                  0 (k + 1))
                 +
                 (BCA.bigi predT (fun (i : int) => - (
                  (BCA.bigi predT (fun (j : int) => p.[j] * q.[n + k - i - j] * r.[i]) 0 (n + k - i + 1))
                   +
                  (BCA.bigi predT (fun (j : int) => - p.[j] * q.[n + n + k - i - j] * r.[i]) (n + k - i + 1) n)))
                  (k + 1) n)
            else zero.
  rewrite polyMSr. rewrite ge0_k ltn_k /=.
   have <-: (BCA.bigi predT (fun (i : int) => (p * q).[k - i] * r.[i]) 0 (k + 1)) =
            (BCA.bigi predT (fun (i : int) =>
              (BCA.bigi predT (fun (j : int) => p.[j] * q.[k - i - j] * r.[i]) 0 (k - i + 1)) 
               +
              (BCA.bigi predT (fun (j : int) => - p.[j] * q.[n + k - i - j] * r.[i]) (k - i + 1) n)) 0 (k + 1)).
 rewrite !BCA.big_seq &(BCA.eq_bigr) => /= i; case/mem_range => ge_i ltn_i.
 rewrite polyMS. have ->:  0 <= k - i /\ k - i < n; [smt | simplify].
 rewrite ZModpRing.mulrDl !BCA.mulr_suml /=. admit.
   have <-: (BCA.bigi predT (fun (i : int) => - (p * q).[n + k - i] * r.[i]) (k + 1) n) =
            (BCA.bigi predT (fun (i : int) =>
             -(
              (BCA.bigi predT (fun (j : int) => p.[j] * q.[n + k - i - j] * r.[i]) 0 (n + k - i + 1)) 
               +
              (BCA.bigi predT (fun (j : int) => - p.[j] * q.[n + n + k - i - j] * r.[i]) (n + k - i + 1) n)
              )) 
              (k + 1) n).
 rewrite !BCA.big_seq &(BCA.eq_bigr) => /= i; case/mem_range => ge_i ltn_i.
 rewrite polyMS. have ->:  0 <= n + k - i /\ n + k - i < n; [smt | simplify].
 rewrite ZModpRing.mulrDl !BCA.mulr_suml /=. admit.
by reflexivity.
  have ->: (p * (q * r)).[k] =
            if 0 <= k /\ k < n
            then (BCA.bigi predT (fun (i : int) => 
                  (BCA.bigi predT (fun (j : int) => p.[i] * q.[k - i - j] * r.[j]) 0 (k - i + 1))
                  +
                  (BCA.bigi predT (fun (j : int) => - p.[i] * q.[n + k - i - j] * r.[j]) (k - i + 1) n))
                  0 (k + 1))
                 +
                 (BCA.bigi predT (fun (i : int) => - (
                  (BCA.bigi predT (fun (j : int) => p.[i] * q.[n + k - i - j] * r.[j]) 0 (n + k - i + 1))
                   +
                  (BCA.bigi predT (fun (j : int) => - p.[i] * q.[n + n + k - i - j] * r.[j]) (n + k - i + 1) n)))
                  (k + 1) n)
            else zero.
admit.
rewrite ge0_k ltn_k /=. rewrite !BCA.big_split.

have ->: (BCA.bigi predT (fun (i : int) =>
          (BCA.bigi predT (fun (j : int) => p.[i] * q.[k - i - j] * r.[j]) 0 (k - i + 1))) 0 (k + 1))
         =
         (BCA.bigi predT (fun (i : int) =>
          (BCA.bigi predT (fun (j : int) => p.[j] * q.[k - i - j] * r.[i]) 0 (k - i + 1))) 0 (k + 1)).
(*
rewrite BCA.big_mapT.
rewrite !BCA.big_seq. rewrite (BCA.exchange_big predT predT _ (range 0 (k - i + t)) (range 0 (k + 1))).  &(BCA.eq_bigr) => /= i; case/mem_range => ge_i ltn_i. -(BCA.exchange_big predT predT).
 rewrite !BCA.big_seq &(BCA.eq_bigr) => /= i; case/mem_range => ge_i ltn_i.
  rewrite polyMS. 
 case: (0 <= n + k - i /\ n + k - i < n) => [[gt0_ki ltn_ki] | /negb_and ]; 2: by rewrite ZModpRing.mul0r.
 rewrite ZModpRing.mulrDl !BCA.mulr_suml /=. admit.
by reflexivity.

  have ->: (p * (q * r)).[k] =
            if 0 <= k /\ k < n
            then (BCA.bigi predT (fun (i : int) => 
                  if 0 <= k - i /\ k - i < n 
                  then (BCA.bigi predT (fun (j : int) => 
                        p.[i] * q.[k - i - j] * r.[j]) 0 (k - i + 1))
                       +
                       (BCA.bigi predT (fun (j : int) => 
                       - p.[i] * q.[n + k - i - j] * r.[j]) (k - i + 1) n)
                  else zero) 0 (k + 1))
                  +
                  (BCA.bigi predT (fun (i : int) => 
                  - (
                  if 0 <= n + k - i /\ n + k - i < n 
                  then (BCA.bigi predT (fun (j : int) => 
                        p.[i] * q.[n + k - i - j] * r.[j]) 0 (n + k - i + 1))
                       +
                       (BCA.bigi predT (fun (j : int) => 
                        - p.[i] * q.[n + n + k - i - j] * r.[j]) (n + k - i + 1) n)
                  else zero)) (k + 1) n)
            else zero.
admit.
rewrite ge0_k ltn_k /=.
   have <-: (BCA.bigi predT (fun (i : int) => (p * q).[k - i] * r.[i]) 0 (k + 1)) =
            (BCA.bigi predT (fun (i : int) =>
             if 0 <= k - i /\ k - i < n 
             then
              (BCA.bigi predT (fun (j : int) => p.[j] * q.[k - i - j] * r.[i]) 0 (k - i + 1)) 
               +
              (BCA.bigi predT (fun (j : int) => - p.[j] * q.[n + k - i - j] * r.[i]) (k - i + 1) n)
             else zero) 0 (k + 1)).
 rewrite !BCA.big_seq &(BCA.eq_bigr) => /= i; case/mem_range => ge_i ltn_i.
 rewrite polyMS.

  have ->: ((p * q) * r).[k] =
            if 0 <= k /\ k < n
            then (BCA.bigi predT (fun (i : int) => 
                  if 0 <= k - i /\ k - i < n 
                  then (BCA.bigi predT (fun (j : int) => 
                        p.[j] * q.[k - i - j] * r.[i] - p.[j] * q.[n + k - i - j] * r.[i]) 0 n)
                  else zero) 0 n)
                  +
                  (BCA.bigi predT (fun (i : int) => 
                  if 0 <= n + k - i /\ n + k - i < n 
                  then (BCA.bigi predT (fun (j : int) => 
                        p.[j] * q.[n + k - i - j] * r.[i] - p.[j] * q.[n + n + k - i - j] * r.[i]) 0 n)
                  else zero) 0 n)
            else zero.
   rewrite polyMEr. rewrite ge0_k ltn_k /= BCA.big_split.
   have <-: (BCA.bigi predT (fun (i : int) => (p * q).[k - i] * r.[i]) 0 n) =
            (BCA.bigi predT (fun (i : int) =>
             if 0 <= k - i /\ k - i < n 
             then (BCA.bigi predT (fun (j : int) => (p.[j] * q.[k - i - j] * r.[i] - p.[j] * q.[n + k - i - j] * r.[i])) 0 n)
             else zero) 0 n).
 
 rewrite !BCA.big_seq &(BCA.eq_bigr) => /= i; case/mem_range => ge_i ltn_i.
   rewrite polyME.
 case: (0 <= k - i /\ k - i < n) => [[gt0_ki ltn_ki] | /negb_and ]; 2: by rewrite ZModpRing.mul0r.
   by rewrite BCA.mulr_suml /= &(BCA.eq_bigr) => j _ /=; rewrite ZModpRing.mulrBl /#.

   have <-: (BCA.bigi predT (fun (i : int) => - (p * q).[n + k - i] * r.[i]) 0 n) =
            (BCA.bigi predT (fun (i : int) =>
             if 0 <= n + k - i /\ n + k - i < n 
             then (BCA.bigi predT (fun (j : int) => (p.[j] * q.[n + k - i - j] * r.[i] - p.[j] * q.[n + n + k - i - j] * r.[i])) 0 n)
             else zero) 0 n).
 admit.
 by reflexivity.

  have ->: (p * (q * r)).[k] =
            if 0 <= k /\ k < n
            then (BCA.bigi predT (fun (i : int) => 
                  if 0 <= k - i /\ k - i < n 
                  then (BCA.bigi predT (fun (j : int) => 
                        p.[i] * q.[k - i - j] * r.[j] - p.[i] * q.[n + k - i - j] * r.[j]) 0 n)
                  else zero) 0 n)
                  +
                  (BCA.bigi predT (fun (i : int) => 
                  if 0 <= n + k - i /\ n + k - i < n 
                  then (BCA.bigi predT (fun (j : int) => 
                        p.[i] * q.[n + k - i - j] * r.[j] - p.[i] * q.[n + n + k - i - j] * r.[j]) 0 n)
                  else zero) 0 n)
            else zero.
   rewrite polyME. rewrite ge0_k ltn_k /= BCA.big_split.
   have <-: (BCA.bigi predT (fun (i : int) =>  p.[i] * (q * r).[k - i]) 0 n) =
            (BCA.bigi predT (fun (i : int) =>
             if 0 <= k - i /\ k - i < n 
             then (BCA.bigi predT (fun (j : int) => (p.[i] * q.[k - i - j] * r.[j] - p.[i] * q.[n + k - i - j] * r.[j])) 0 n)
             else zero) 0 n).
 
 rewrite !BCA.big_seq &(BCA.eq_bigr) => /= i; case/mem_range => ge_i ltn_i.
   rewrite polyMEr.
 case: (0 <= k - i /\ k - i < n) => [[gt0_ki ltn_ki] | /negb_and ]; 2: by rewrite ZModpRing.mulr0.
    rewrite BCA.mulr_sumr /= &(BCA.eq_bigr) => j _ /=; rewrite ZModpRing.mulrBr ?ZModpRing.mulrA /#.
   have <-: (BCA.bigi predT (fun (i : int) => - p.[i] * (q * r).[n + k - i]) 0 n) =
            (BCA.bigi predT (fun (i : int) =>
             if 0 <= n + k - i /\ n + k - i < n 
             then (BCA.bigi predT (fun (j : int) => (p.[i] * q.[n + k - i - j] * r.[j] - p.[i] * q.[n + n + k - i - j] * r.[j])) 0 n)
             else zero) 0 n).
  admit.
  by reflexivity.
  rewrite ge0_k ltn_k /=.
  have ->: (BCA.bigi predT (fun (i : int) =>
            if 0 <= k - i /\ k - i < n 
            then (BCA.bigi predT (fun (j : int) => (p.[i] * q.[k - i - j] * r.[j] - p.[i] * q.[n + k - i - j] * r.[j])) 0 n)
            else zero) 0 n) =
           (BCA.bigi predT (fun (i : int) =>
            if 0 <= k - i /\ k - i < n 
            then (BCA.bigi predT (fun (j : int) => (p.[j] * q.[k - i - j] * r.[i] - p.[j] * q.[n + k - i - j] * r.[i])) 0 n)
            else zero) 0 n).
(* rewrite ge0_k ltn_k /=.
rewrite BCA.exchange_big /=. rewrite !BCA.big_seq &(BCA.eq_bigr) => /= i. *)
rewrite -!BCA.big_mkcond. 
rewrite BCA.big_seq_cond.
rewrite (BCA.big_seq_cond (fun (i : int) => 0 <= k - i /\ k - i < n)) /=.
rewrite BCA.exchange_big /=.
rewrite BCA.big_seq.
rewrite BCA.exchange_big /=.
rewrite (BCA.exchange_big ((fun (i : int) => (i \in range 0 n) /\ 0 <= k - i /\ k - i < n)) predT).
rewrite BCA.big_seq /=.
rewrite BCA.exchange_big /=.
rewrite BCA.exchange_big /=.  eq_sym BCA.exchange_big /=. rewrite &(BCA.eq_big). rewrite BCA.exchange_big.*)
admit. admit.
qed.

lemma mul1p : left_id poly1 polyM.
proof.
  move=> p; apply: poly_eqP => c ge0_c ltn_c.
  rewrite polyME ge0_c ltn_c /= (BCA.big_int_recl (n - 1)) //=; 1: rewrite -(lez_add2r 1) /= ge1_n. 
  rewrite polyCE /= ZModpRing.mul1r BCA.big_seq BCA.big1 -1:?addr0 //= 2:ZModpRing.addr0; last first.
   have ->: p.[n + c] = zero; 2: by rewrite ZModpRing.mulr0 ZModpRing.subr0.
     by apply /gedeg_coeff /(lez_trans n); [apply len_deg | rewrite lez_addl].
  move=> i; rewrite mem_range=> -[ge0_i _]; rewrite polyCE.
  by rewrite addz1_neq0 //= 2!ZModpRing.mul0r ZModpRing.subrr.
qed.

lemma mul0p : left_zero poly0 polyM.
proof.
  move=> p; apply/poly_eqP=> c ge0_c ltn_c; rewrite poly0E polyME ge0_c ltn_c /=.
  by rewrite BCA.big1 //= => i _; rewrite poly0E 2!ZModpRing.mul0r ZModpRing.subrr.
qed.

lemma mulpDl: left_distributive polyM polyD.
proof.
  move=> p q r; apply: poly_eqP => c ge0_c ltn_c; rewrite !(polyME, polyDE) ge0_c ltn_c /=.
  by rewrite -BCA.big_split &(BCA.eq_bigr) => /= i _;
             rewrite polyDE 2!ZModpRing.mulrDl ZModpRing.opprD;
             rewrite ZModpRing.addrCA -ZModpRing.addrA ZModpRing.addrCA ZModpRing.addrA.
qed.


lemma onep_neq0 : poly1 <> poly0.
proof.  
  apply/negP => /poly_eqP /(_ 0); rewrite !polyCE ZModpRing.oner_neq0 implybF /=.
  by apply /(ltr_le_trans 1) /ge1_n.
qed.

(*
pred nilpotent (a : coeff) = exists (n : int), inzmod (exp (asint a) n) = zero.
pred unitp (p : poly) = Coeff.unit p.[0] /\ forall (i : int), 0 < i => nilpotent p.[i].

op polyV (p : poly) =
  if deg p = 1 then polyC (Coeff.inv p.[0]) else p.

lemma degV (p : poly) : deg (polyV p) = deg p.
proof.
rewrite /polyV; case: (deg p = 1); last done.
by case/deg_eq1=> c [nz_c ->>]; rewrite !degC polyCE /= ZModpRing.invr_eq0.
qed.
*)

clone import Ring.ComRing as PolyRing with
    type t <- poly ,
    op zeror <- poly0,
    op oner <- poly1,
    op ( + ) <- polyD,
    op [ - ] <- polyN,
    op ( * ) <- polyM
  proof addrA     by apply ZPoly.addrA
  proof addrC     by apply ZPoly.addrC
  proof add0r     by apply ZPoly.add0r
  proof addNr     by apply ZPoly.addNr
  proof mulrA     by apply mulpA
  proof mulrC     by apply mulpC
  proof mul1r     by apply mul1p
  proof mulrDl    by apply mulpDl
  proof oner_neq0 by apply onep_neq0.

(*
realize unitout.
proof.

move=> p @/unitp @/polyV; case: (deg p = 1) => //=.
move=> dp_eq1 unitN_p0; apply/poly_eqP => c ge0_c.
case: (c < 1) => [lt1_c|/lerNgt ge1_c]; last first.
- rewrite !(@gedeg_coeff _ c) 2:dp_eq1 //.
  by apply/(ler_trans _ _ _ _ ge1_c)/degC_le.
- suff ->: c = 0; first by rewrite polyCE /= invr_out //; apply /ZModpRing.unitout /unitN_p0.
  by rewrite eqr_le ge0_c /= -ltz1.
qed.


realize mulVr.
proof.
move=> p inv_p; apply/poly_eqP=> c /ler_eqVlt [<<-|].
+ rewrite polyCE /= polyME /= BCA.big_int1 /= /polyV.
  by case: inv_p => -> inv_p0 /=; rewrite polyCE /= ZModpRing.mulVr.
+ move=> gt0_c; rewrite polyME polyCE gtr_eqF //=.
  rewrite BCA.big_seq BCA.big1 //= => i; rewrite mem_range.
  case: inv_p => @/polyV ^ degp -> inv_p0 [+ lt_i_Sc] - /ler_eqVlt [<<-|] /=.
  - by rewrite (gedeg_coeff _ c) -1:ZModpRing.mulr0 // degp /#.
  - move=> gt0_i; rewrite (gedeg_coeff _ i) -1:ZModpRing.mul0r //.
    by apply/(ler_trans _ _ _ (degC_le _)) => /#.
qed.

realize unitP.
proof. admit. qed.
(*
move=> p q ^pMqE /(congr1 deg); rewrite deg1.
move/(congr1 ((+) 1)) => /=; rewrite addrC; move: pMqE.
case: (deg p = 0) => [/deg_eq0->|nz_p].
- by rewrite mulpC mul0p eq_sym onep_neq0.
case: (deg q = 0) => [/deg_eq0->|nz_q].
- by rewrite mul0p eq_sym onep_neq0.
rewrite degM -1?deg_eq0 // => ME eq.
have {eq}[]: deg p = 1 /\ deg q = 1 by smt(ge0_deg).
move/deg_eq1=> [cp [nz_cp ->>]]; move/deg_eq1=> [cq [nz_cq ->>]].
move/poly_eqP: ME => /(_ 0 _) //; rewrite polyCE /=.
rewrite polyME BCA.big_int1 /= => /unitP @/unitp -> /=.
by rewrite deg_eq1; exists cp.
qed. *)
*)

(* -------------------------------------------------------------------- *)
theory BigPoly.
clone include BigComRing with
    type t <- poly,
    op CR.zeror <- poly0,
    op CR.oner <- poly1,
    op CR.( + ) <- polyD,
    op CR.([-]) <- polyN,
    op CR.( * ) <- polyM,
    op CR.intmul <- PolyRing.intmul,
    op CR.ofint <- PolyRing.ofint,
    op CR.exp <- PolyRing.exp
  proof CR.addrA     by apply: PolyRing.addrA    
  proof CR.addrC     by apply: PolyRing.addrC    
  proof CR.add0r     by apply: PolyRing.add0r    
  proof CR.addNr     by apply: PolyRing.addNr    
  proof CR.oner_neq0 by apply: PolyRing.oner_neq0
  proof CR.mulrA     by apply: PolyRing.mulrA    
  proof CR.mulrC     by apply: PolyRing.mulrC    
  proof CR.mul1r     by apply: PolyRing.mul1r    
  proof CR.mulrDl    by apply: PolyRing.mulrDl

  rename [theory] "BAdd" as "PCA"
         [theory] "BMul" as "PCM"

  remove abbrev CR.(-)
  remove abbrev CR.(/).

lemma polysumE ['a] P F s k :
  (PCA.big<:'a> P F s).[k] = BCA.big P (fun i => (F i).[k]) s.
proof.
  elim: s => /= [|x s ih]; first by rewrite poly0E.
  rewrite !BCA.big_cons -ih PCA.big_cons /=.
  by rewrite -polyDE -(fun_if (fun q => q.[k])).
qed.

end BigPoly.

import BigPoly.

(* -------------------------------------------------------------------- *)
op peval (p : poly) (a : coeff) =
  BCA.bigi predT (fun i => p.[i] * ZModpRing.exp a i) 0 (deg p + 1).

(* -------------------------------------------------------------------- *)
abbrev root p a = peval p a = zero.
