(* ----------------------------------- *)
(*  Require/Import Theories            *)
(* ----------------------------------- *)

(* --- Built-in --- *)
require import AllCore List Ring Bigalg StdBigop StdOrder IntDiv ZModP.
require (*--*) Subtype.
(*---*) import Bigint IntID IntOrder.

(* ----------------------------------- *)
(*  Saber's Polynomial Quotient Rings  *)
(*  Rp = Zp [X] / X ^ n + 1            *)
(* ----------------------------------- *)

(* --- Basics --- *)
(* -- Constants -- *)
const p : { int | 2 <= p } as ge2_coeffp.

const en : { int | 0 <= en } as ge0_en. 
const n : int = 2 ^ en.

lemma ge1_n: 1 <= n by rewrite exprn_ege1; first apply ge0_en.

(* -- Types -- *)
type coeff.
type poly.

(* -- Theories -- *)
(* Coefficient Ring *)
clone import ZModRing as Coeff with
    op p <- p,
    type zmod <- coeff
  proof ge2_p by apply ge2_coeffp.

(* Iterative Application of Operations on List of Coefficients  *)
clone import BigComRing as BigCf with
    type t <- coeff,
    pred CR.unit <- Coeff.unit,
    op CR.zeror <- Coeff.zero,
    op CR.oner <- Coeff.one,
    op CR.( + ) <- Coeff.( + ),
    op CR.([-]) <- Coeff.([-]),
    op CR.( * ) <- Coeff.( * ),
    op CR.invr <- Coeff.inv,
    op CR.intmul <- Coeff.ZModpRing.intmul,
    op CR.ofint <- Coeff.ZModpRing.ofint,
    op CR.exp <- Coeff.ZModpRing.exp
  proof CR.addrA by apply Coeff.ZModpRing.addrA
  proof CR.addrC by apply Coeff.ZModpRing.addrC
  proof CR.add0r by apply Coeff.ZModpRing.add0r
  proof CR.addNr by apply Coeff.ZModpRing.addNr
  proof CR.oner_neq0 by apply Coeff.ZModpRing.oner_neq0
  proof CR.mulrA by apply Coeff.ZModpRing.mulrA
  proof CR.mulrC by apply Coeff.ZModpRing.mulrC
  proof CR.mul1r by apply Coeff.ZModpRing.mul1r
  proof CR.mulrDl by apply Coeff.ZModpRing.mulrDl
  proof CR.mulVr by apply Coeff.ZModpRing.mulVr
  proof CR.unitP by apply Coeff.ZModpRing.unitP
  proof CR.unitout by apply Coeff.ZModpRing.unitout

  rename [theory] "BAdd" as "BCA"
         [theory] "BMul" as "BCM"

  remove abbrev CR.(-)
  remove abbrev CR.(/).

(* --- Polynomial Quotient Ring Elements, Operations, and Structure/Properties --- *)
(* -- Polynomial Elements -- *)
(* - Definition and Properties - *)
type prepoly = int -> coeff.

inductive ispoly (p : prepoly) =
| IsPoly of
      (forall c, c < 0 => p c = zero)
    & (exists d, d < n /\ forall c, (d < c) => p c = zero).

clone include Subtype with 
    type T   <- prepoly,
    type sT  <- poly,
    pred P   <- ispoly,
    op wsT <- (fun _ => zero)
  rename "insub" as "to_poly"
  rename "val"   as "of_poly".

op "_.[_]" (p : poly) (i : int) = (of_poly p) i.

lemma lt0_coeff (p : poly) (c : int) : c < 0 => p.[c] = zero.
proof.
  by move=> lt0_c; rewrite /"_.[_]"; case: (of_polyP p) => /(_ _ lt0_c).
qed.

op deg (p : poly) = argmin idfun (fun (i : int) => forall (j : int), (i <= j) => p.[j] = zero).

lemma ge0_deg (p : poly) : 0 <= deg p.
proof. rewrite /deg &(ge0_argmin). qed.

lemma gedeg_coeff (p : poly) (c : int) : deg p <= c => p.[c] = zero.
proof.
  move=> le_p_c; pose P p i := forall j, (i <= j)%Int => p.[j] = zero.
  case: (of_polyP p) => [wf_p [d hd]]; move: hd; case => gtd_n pc0; move: (argminP idfun (P p)).
  move/(_ (max (d+1) 0) _ _) => @/P @/idfun /=; first exact: maxrr.
  - by move=> j le_d_j; apply: pc0 => /#.
  by apply; apply: le_p_c.
qed.

lemma gedeg_coeff_contra (p : poly) (c : int) : p.[c] <> zero => c < deg p.
proof. move: (gedeg_coeff p c); rewrite lerNgt; apply (contraR (c < deg p) (p.[c] = zero)). qed.

lemma len_deg (p : poly) : deg p <= n.
proof. 
  rewrite /deg; case: (of_polyP p) => [wf_p [d hd]]; move: hd; case => gtd_n pc0.
  pose P (i : int) := forall (j : int), (i <= j) => p.[j] = zero.
  have minz_maxd10: P (idfun (max (d + 1) 0)); 1: rewrite /idfun /max /P => j. 
  case (d + 1 < 0) => [lt0_d1 ge0_j | gt0_d1 ged1_j]; move: (pc0 j); have ->: d < j; 2, 4: trivial.
   by apply /(ltr_le_trans 0) /ge0_j /(ltz_trans (d + 1)) /lt0_d1; rewrite (ltz_addl d 1). 
   by rewrite addzC lez_add1r in ged1_j.
  have learg_maxd10: argmin idfun P <= max (d + 1) 0.
   move: (argmin_min idfun P (max (d + 1) 0)) => amin. 
    apply (contraL (0 <= max (d + 1) 0 && max (d + 1) 0 < argmin idfun P) (P (idfun (max (d + 1) 0)))) in amin.
    rewrite minz_maxd10 /= andabP negb_and -ltzNge -lezNgt in amin.
   move: amin; case; by rewrite // ltzNge maxrr.
  apply /(lez_trans (max (d + 1) 0) _ _ learg_maxd10); rewrite ler_maxrP; split.
   by rewrite addzC lez_add1r. 
   by apply /(lez_trans 1) /ge1_n.     
qed.

lemma len_maxdegs (p q : poly) : max (deg p) (deg q) <= n.
proof. by rewrite /max; case (deg p < deg q) => ?; apply len_deg. qed.

lemma ltn_maxdegs1 (p q : poly) : max (deg p) (deg q) - 1 < n.
proof. by rewrite -(lez_add1r) addzC /= len_maxdegs. qed. 

lemma ge0_maxdegs (p q : poly) : 0 <= max (deg p) (deg q).
proof. by rewrite /max; case (deg p < deg q) => ?; apply ge0_deg. qed.

(* - Basic Construction and Operations - *)
op prepolyC  (c   : coeff) = fun i => if i = 0 then c else zero.
op prepolyXn (k   : int  ) = fun i => if 0 <= k /\ k < n /\ i = k then one else zero.
op prepolyD  (p q : poly ) = fun i => p.[i] + q.[i].
op prepolyN  (p   : poly ) = fun i => - p.[i].

(* p * q = \sum_0^{n - 1} (p.[i] * q.[k - i] - p.[i] * q.[n + k - i]) *)
op prepolyM (p q : poly) = fun (k : int) =>
  if 0 <= k /\ k < n
  then BCA.bigi predT (fun (i : int) => p.[i] * q.[k - i] - p.[i] * q.[n + k - i]) 0 n
  else zero.

op prepolyZ (z : coeff) (p : poly) = fun k =>
  z * p.[k].

lemma ispolyC (c : coeff) : ispoly (prepolyC c).
proof.
  split => @/prepolyC [c' ?|]; 1: by rewrite ltr_eqF.
   exists 0; split; 1: by apply /(ltr_le_trans 1) /ge1_n. 
    by move => c' gt1_c'; rewrite gtr_eqF.
qed.

lemma ispolyXn (k : int) : ispoly (prepolyXn k).
proof.
  split => @/prepolyXn [c lt0_c|].
   by case: (0 <= k) => //= ge0_k; rewrite ltr_eqF //#.
   case: (k < n) => krel; first exists k; split; 1: by apply krel.
    by move => c; rewrite ltz_def -neqF; case => neq_ck ?; rewrite neq_ck. 
    by exists (n - 1); split; 1: rewrite -(ltz_add2r 1) /= (ltz_addl n).
qed.

lemma ispolyN (p : poly) : ispoly (prepolyN p).
proof.
  split => @/prepolyN [c lt0_c|]; 1: by rewrite ZModpRing.oppr_eq0 lt0_coeff.
   exists (deg p - 1); split; 1: by apply /(ltr_le_trans (deg p)) /len_deg;
          rewrite -(ltz_add2r 1) /= (ltz_addl).  
    by move => c ltdegp1_c; rewrite -lez_add1r addzC /= in ltdegp1_c; 
       rewrite ZModpRing.oppr_eq0 gedeg_coeff.
qed.

lemma ispolyD (p q : poly) : ispoly (prepolyD p q).
proof.
  split=> @/prepolyD [c lt0_c|]; 1: by rewrite !lt0_coeff // ZModpRing.addr0. 
  exists (max (deg p) (deg q) - 1); split; 1: apply ltn_maxdegs1; move => c.
   by rewrite /max; case (deg p < deg q) => deg_rel ltc_deg1; 
           have: (p.[c] = zero /\ q.[c] = zero); 
           [| case => p0 q0; rewrite p0 q0 ZModule.add0r | | case => p0 q0; rewrite p0 q0 ZModule.add0r];
           split; rewrite gedeg_coeff //=; rewrite -lez_add1r addzC /= in ltc_deg1;
           [apply /ltzW /(ltr_le_trans (deg q)) | | | rewrite -lezNgt in deg_rel;apply (lez_trans (deg p))]. 
qed.

lemma ispolyM (p q : poly) : ispoly (prepolyM p q).
proof.
  split => @/prepolyM [c lt0_c|]; 1: by rewrite ltzNge -neqF in lt0_c; rewrite lt0_c //=.
   exists (n - 1); split; 1: by rewrite -(ltz_add2r 1) /= ltz_addl.
    move => c; rewrite -(lez_add1r) addzC /= => lec_n. 
     by move: (lez_lt_asym n c); rewrite andabP negb_and -(implyNb) lec_n /= -neqF => cnf; rewrite cnf //=.
qed.

lemma ispolyZ z p : ispoly (prepolyZ z p).
proof.  
  by split => @/prepolyZ [c lt0_c|]; 
           [| exists (deg p - 1); split; [rewrite -lez_add1r addzC /= len_deg | move => c ltc]]; 
           rewrite /( * ) -eq_inzmod mod0z; have ->: asint z * asint p.[c] = 0; 
           [| apply mod0z | | apply mod0z]; rewrite mulf_eq0 -zeroE (asint_eq (p.[c])); right; 
           [apply lt0_coeff | apply gedeg_coeff; rewrite -lez_add1r addzC /= in ltc]. 
qed.

lemma poly_eqP (p q : poly) : p = q <=> (forall c, 0 <= c => c < n => p.[c] = q.[c]).
proof.
  split=> [->//|eq_coeff]; apply/of_poly_inj/fun_ext => c.
  case: (c < 0 \/ n <= c); [case => [lt0_c | gen_c] | by rewrite negb_or -ltzNge -lezNgt; case; apply eq_coeff]. 
   by rewrite -/"_.[_]" !lt0_coeff.
   by rewrite -/"_.[_]" !gedeg_coeff; 1, 2: apply /(lez_trans n); 1, 3: apply len_deg.
qed.

op polyC  c   = to_polyd (prepolyC  c).
op polyXn k   = to_polyd (prepolyXn k).
op polyN  p   = to_polyd (prepolyN  p).
op polyD  p q = to_polyd (prepolyD  p q).
op polyM  p q = to_polyd (prepolyM p q).
op polyZ  z p = to_polyd (prepolyZ z p).

abbrev poly0  = polyC  zero.
abbrev poly1  = polyC  one.
abbrev polyX  = polyXn 1.
abbrev X      = polyXn 1.
abbrev ( + )  = polyD.
abbrev [ - ]  = polyN.
abbrev ( - )  = fun p q => p + (-q).
abbrev ( * )  = polyM.
abbrev ( ** ) = polyZ.

(* --- Basic Operations w.r.t. a Single Coefficient --- *)
lemma coeffE p k : ispoly p => (to_polyd p).[k] = p k.
proof. by move=> ?; rewrite /"_.[_]" to_polydK. qed.

lemma polyCE c k : (polyC c).[k] = if k = 0 then c else zero.
proof. by rewrite coeffE 1:ispolyC. qed.

lemma poly0E k : poly0.[k] = zero.
proof. by rewrite polyCE if_same. qed.

lemma polyNE p k : (-p).[k] = - p.[k].
proof. by rewrite coeffE 1:ispolyN. qed.

lemma polyDE p q k : (p + q).[k] = p.[k] + q.[k].
proof. by rewrite coeffE 1:ispolyD. qed.

lemma polyME p q k : (p * q).[k] =
  if 0 <= k /\ k < n
  then BCA.bigi predT (fun (i : int) => p.[i] * q.[k - i] - p.[i] * q.[n + k - i]) 0 n
  else zero.
proof. by rewrite coeffE 1:ispolyM. qed.

lemma polyZE z p k : (z ** p).[k] = z * p.[k].
proof. by rewrite coeffE 1:ispolyZ. qed.

hint rewrite coeffpE : poly0E polyDE polyNE polyME polyZE.

(* --- Properties Regarding the Polynomial Degree --- *)
lemma degP p c :
     0 < c
  => p.[c-1] <> zero
  => (forall i, c <= i => p.[i] = zero)
  => deg p = c.
proof.
  move=> ge0_c nz_p_cB1 degc @/deg; apply: argmin_eq => @/idfun /=.
  - by apply/ltrW. 
  - by apply: degc.
  move=> j [ge0_j lt_jc]; rewrite negb_forall /=.
  by exists (c-1); apply/negP => /(_ _); first by move=> /#.
qed.

lemma degC c : deg (polyC c) = if c = zero then 0 else 1.
proof.
  case: (c = zero) => [->|nz_c]; last first.
  - apply: degP => //=; first by rewrite polyCE.
   by move=> i ge1_i; rewrite polyCE gtr_eqF //#.
  rewrite /deg; apply: argmin_eq => @/idfun //=.
  - by move=> j _; rewrite poly0E.
  - by move=> j; apply: contraL => _ /#.
qed.

lemma degC_le c : deg (polyC c) <= 1.
proof. by rewrite degC; case: (c = zero). qed.

lemma deg0 : deg poly0 = 0.
proof. by rewrite degC. qed.

lemma deg1 : deg poly1 = 1.
proof.
  apply: degP => //=; first by rewrite polyCE /= ZModpRing.oner_neq0.
  by move=> c ge1_c; rewrite polyCE gtr_eqF //#.
qed.

lemma deg_eq0 p : (deg p = 0) <=> (p = poly0).
proof.
  split=> [z_degp|->]; last by rewrite deg0.
  apply/poly_eqP=> c ge0_c ltn_c; rewrite poly0E.
  by apply/gedeg_coeff; rewrite z_degp.
qed.

lemma deg_eq1 p : (deg p = 1) <=> (exists c, c <> zero /\ p = polyC c).
proof.
  split=> [eq1_degp|[c [nz_c ->>]]]; last first.
  + by apply: degP => //= => [|i ge1_i]; rewrite polyCE //= gtr_eqF /#.
  have pC: forall i, 1 <= i => p.[i] = zero.
  + by move=> i ge1_i; apply: gedeg_coeff; rewrite eq1_degp.
  exists p.[0]; split; last first.
  + apply/poly_eqP => c /ler_eqVlt -[<<-|]; first by rewrite polyCE.
    by move=> gt0_c ltn_c; rewrite polyCE gtr_eqF //= &(pC) /#.
  apply: contraL eq1_degp => z_p0; suff ->: p = poly0 by rewrite deg0.
  apply/poly_eqP=> c; rewrite poly0E => /ler_eqVlt [<<-//|].
  by move=> gt0_c ltn_c; apply: pC => /#.
qed.

lemma coeff_degB1_neq0 p : p <> poly0 => p.[deg p - 1] <> zero.
proof.
  rewrite -deg_eq0 eqr_le ge0_deg /= -ltrNge => gt0_deg.
  pose P i := forall j, (i <= j)%Int => p.[j] = zero.
  apply/negP => zp; have := argmin_min idfun P (deg p - 1) _; 1: smt().
  move=> @/idfun /= j /ler_eqVlt [<<-//| ltj].
  by apply: gedeg_coeff => /#.
qed.

(* --- Rp is a Z-Module (Hence, has all the properties of a Z-Module) --- *)
clone import Ring.ZModule as ZPoly with
    type t <- poly,
    op zeror <- poly0,
    op (+) <- polyD,
    op [-] <- polyN
  proof *.

  realize addrA.
  proof. by move=> p q r; apply/poly_eqP=> c; rewrite !coeffpE ZModpRing.addrA. qed.

  realize addrC.
  proof. by move=> p q; apply/poly_eqP=> c; rewrite !coeffpE ZModpRing.addrC. qed.

  realize add0r.
  proof. by move=> p; apply/poly_eqP => c; rewrite !coeffpE ZModpRing.add0r. qed.

  realize addNr.
  proof. by move=> p; apply/poly_eqP => c; rewrite !coeffpE ZModpRing.addNr. qed.

(* --- Properties of Polynomial Multiplication  --- *)
(* Polynomial Multiplication (As Defined Above) Can Be Split *)
lemma polyMS (p q : poly) (k : int) : (p * q).[k] =
  if (0 <= k /\ k < n)
  then BCA.bigi predT (fun i => p.[i] * q.[k - i]) 0 (k + 1) + 
       BCA.bigi predT (fun i => - (p.[i] * q.[n + k - i])) (k + 1) n
  else zero.
proof.
  pose F1 i := p.[i] * q.[k - i]; pose F2 i := - (p.[i] * q.[n + k - i]).
  pose F i := F1 i + F2 i.
  rewrite polyME; case (0 <= k /\ k < n) => [ [ge0_k ltn_k] | //].
   have <-: F = fun (i : int) => (p.[i] * q.[k - i] - p.[i] * q.[n + k - i]).
    by rewrite fun_ext /(==) /F /F1 /F2 => x.
   rewrite (BCA.big_split predT F1 F2 (range 0 n)) (BCA.big_cat_int (k + 1) 0 n _ F1) 
            3: (BCA.big_cat_int (k + 1) 0 n _ F2);
            [by apply /(lez_trans k); 2: rewrite lez_addl | by rewrite addzC lez_add1r |
             by apply /(lez_trans k); 2: rewrite lez_addl | by rewrite addzC lez_add1r |].

   have ->: (BCA.bigi predT F1 (k + 1) n) = zero.
    rewrite BCA.big_int BCA.big1 //= => i; case => gek1_i ltn_i.
    rewrite /F1 /( * ) -eq_inzmod mod0z.
    have ->: asint p.[i] * asint q.[k - i] = 0; 2: by apply mod0z.
     apply mulf_eq0; right.
      by rewrite -zeroE asint_eq lt0_coeff // subz_lt0; rewrite addzC lez_add1r in gek1_i.
      
   have ->: (BCA.bigi predT F2 0 (k + 1)) = zero.    
    rewrite BCA.big_int BCA.big1 //= => i; case => ge0_i ltk1_i.
    rewrite /F2 /( * ) ZModpRing.oppr_eq0 -eq_inzmod mod0z.
    have ->: asint p.[i] * asint q.[n + k - i] = 0; 2: by apply mod0z.
     apply mulf_eq0; right.
       by rewrite -zeroE asint_eq gedeg_coeff // (lez_trans n) 1:len_deg -(lez_add2r i) -addzA /= lez_add2l;
                  rewrite-lez_add1r {1}addzC -(lez_add2r (-1)) /= in ltk1_i.              
   
   by rewrite -ZModpRing.addrA 2!ZModpRing.add0r.
qed.

(* -- Commutativity of Polynomial Multiplication -- *)
lemma mulpC : commutative ( * ).
proof.
  move=> p q; apply: poly_eqP => k ge0_k ltn_k; rewrite !polyMS ge0_k ltn_k /=.
  pose F1 i := p.[i] * q.[k - i]; pose F2 i :=  - (p.[i] * q.[n + k - i]).
  pose F1' i := q.[i] * p.[k - i]; pose F2' i :=  - (q.[i] * p.[n + k - i]).
  pose F i := F1 i + F2 i; pose F' i := F1' i + F2' i.
  pose K j := k - j; pose NK j := n + k - j.
  rewrite (@BCA.big_reindex predT F1 K K) 1:/# (@BCA.big_reindex predT F2 NK NK) 1:/#.
  rewrite (predT_comp K) (predT_comp NK) /(\o) /=. 
  pose s1 := map _ _; pose s2 := map _ _. 
  have ->: BCA.big predT (fun (x : int) => F1 (K x)) s1 = BCA.bigi predT F1' 0 (k + 1).
  apply: (eq_trans _ _ _ (BCA.eq_big_perm _ _ _ (range 0 (k + 1)) _)).
   rewrite uniq_perm_eq 2:&(range_uniq) /s.
    rewrite map_inj_in_uniq 2:&(range_uniq) => x y.
     by rewrite !mem_range /K /#.
     move=> x; split => [/mapP[y []]|]; 1: rewrite !mem_range /#.
     rewrite !mem_range => *; apply/mapP; exists (K x).
     by rewrite !mem_range /K /#.
   apply: BCA.eq_bigr => /= i _ @/K @/F1 @/F1'; rewrite ZModpRing.mulrC /#.
  have -> //: BCA.big predT (fun (x : int) => F2 (NK x)) s2 = BCA.bigi predT F2' (k + 1) n.
   apply: (eq_trans _ _ _ (BCA.eq_big_perm _ _ _ (range (k + 1) n) _)).
    rewrite uniq_perm_eq 2:&(range_uniq) /s.
     rewrite map_inj_in_uniq 2:&(range_uniq) => x y.
      by rewrite !mem_range /NK /#.
     move=> x; split => [/mapP[y []]|]; 1: rewrite !mem_range /#.
      rewrite !mem_range => *; apply/mapP; exists (NK x).
      by rewrite !mem_range /NK /#.
   apply: BCA.eq_bigr => /= i _ @/NK @/F2 @/F2'; rewrite ZModpRing.mulrC /#.
qed.

(* Polynomial Multiplication Alternative Order of Computation *)
lemma polyMEr (p q : poly) (k : int) : (p * q).[k] =
  if 0 <= k /\ k < n 
  then (BCA.bigi predT (fun (i : int) => (p.[k - i] * q.[i] - p.[n + k - i] * q.[i])) 0 n)
  else zero.
proof. 
  rewrite mulpC !polyME; case (0 <= k /\ k < n) => [[gt0_k ltn_k] | //].
  apply BCA.eq_big_int => i /=; case => ge0_i ltn_i; rewrite /#.
qed.  

(* Polynomial Multiplication Alternative Order of Computation Can Be Split *)
lemma polyMSr (p q : poly) (k : int) : (p * q).[k] =
  if (0 <= k /\ k < n)
  then BCA.bigi predT (fun i => p.[k - i] * q.[i]) 0 (k + 1) + 
       BCA.bigi predT (fun i => - (p.[n + k - i] * q.[i])) (k + 1) n
  else zero.
proof. 
  rewrite mulpC !polyMS; case (0 <= k /\ k < n) => [[gt0_k ltn_k] | //].
   have ->: (BCA.bigi predT (fun (i : int) => q.[i] * p.[k - i]) 0 (k + 1)) =
            (BCA.bigi predT (fun (i : int) => p.[k - i] * q.[i]) 0 (k + 1)).
    apply BCA.eq_big_int => i /=; case => ge0_i ltn_i; rewrite /#.
   have -> //: (BCA.bigi predT (fun (i : int) => - q.[i] * p.[n + k - i]) (k + 1) n) =
            (BCA.bigi predT (fun (i : int) => - p.[n + k - i] * q.[i]) (k + 1) n).
    apply BCA.eq_big_int => i /=; case => ge0_i ltn_i; rewrite /#.
qed.

(* -- Helper Lemmas for Associativity of Polynomial Multiplication -- *)
(* (p * q) * r *)
lemma eq_pre_mulpA_left (p q r : poly) (k : int) : ((p * q) * r).[k] =
  if 0 <= k /\ k < n
  then  (BCA.bigi predT (fun (i : int) => 
        (BCA.bigi predT (fun (j : int) => p.[j] * q.[k - i - j] * r.[i]) 0 n)) 0 (k + 1))
        +
        (BCA.bigi predT (fun (i : int) => 
         (BCA.bigi predT (fun (j : int) => - p.[j] * q.[n + k - i - j] * r.[i]) 0 n)) 0 (k + 1))
        -
        ((BCA.bigi predT (fun (i : int) =>
         (BCA.bigi predT (fun (j : int) => p.[j] * q.[n + k - i - j] * r.[i]) 0 n)) (k + 1) n)
        -
        (BCA.bigi predT (fun (i : int) =>
         (BCA.bigi predT (fun (j : int) => p.[j] * q.[n + n + k - i - j] * r.[i]) 0 n)) (k + 1) n))
  else zero.  
proof.
  rewrite polyMSr; case (0 <= k /\ k < n) => [[ge0_k ltn_k] |] //.
    have <-: (BCA.bigi predT (fun (i : int) => (p * q).[k - i] * r.[i]) 0 (k + 1)) 
           =
           (BCA.bigi predT (fun (i : int) =>
            (BCA.bigi predT (fun (j : int) => p.[j] * q.[k - i - j] * r.[i]) 0 n)) 0 (k + 1)) 
           +
           (BCA.bigi predT (fun (i : int) =>
            (BCA.bigi predT (fun (j : int) => - p.[j] * q.[n + k - i - j] * r.[i]) 0 n)) 0 (k + 1)).
    rewrite -BCA.big_split !BCA.big_seq &(BCA.eq_bigr) => /= i; case/mem_range => ge0_i ltk1_i.
    rewrite polyME; have ->: 0 <= k - i /\ k - i < n; 1: smt.
    rewrite /= !BCA.mulr_suml /= BCA.sumrD /= !BCA.big_seq &(BCA.eq_bigr) => i0 /=. 
    case /mem_range => ge0_i0 ltn_i0; rewrite ZModpRing.mulrBl /#.
   
    have <- //: (BCA.bigi predT (fun (i : int) => - (p * q).[n + k - i] * r.[i]) (k + 1) n)%BCA 
           =
           -(
             (BCA.bigi predT (fun (i : int) =>
              (BCA.bigi predT (fun (j : int) => 
               p.[j] * q.[n + k - i - j] * r.[i]) 0 n)) (k + 1) n) -
             (BCA.bigi predT (fun (i : int) => 
              (BCA.bigi predT (fun (j : int) => 
               p.[j] * q.[n + n + k - i - j] * r.[i]) 0 n)) (k + 1) n)
            ).
  rewrite -BCA.sumrN ZModpRing.eqr_opp BCA.sumrN -BCA.big_split /= !BCA.big_seq &(BCA.eq_bigr) => i /=.
   case /mem_range => gek1_i ltn_i; rewrite polyME; have ->: 0 <= n + k - i /\ n + k - i < n; 1: smt.
   rewrite /= !BCA.mulr_suml BCA.sumrN BCA.sumrD /= !BCA.big_seq &(BCA.eq_bigr) => i0 /=.
    case /mem_range => ge0_i0 ltn_i0; rewrite ZModpRing.mulrBl /#.
qed.

(* Rewritten Two Middle Terms In Result of eq_pre_mulpA_left Lemma *)
lemma eq_bigterm2_mulpA_left_min (p q r : poly) (k : int) :
        -
        ((BCA.bigi predT (fun (i : int) =>
         (BCA.bigi predT (fun (j : int) => p.[j] * q.[n + k - i - j] * r.[i]) 0 n)) (k + 1) n)
        -
        (BCA.bigi predT (fun (i : int) =>
         (BCA.bigi predT (fun (j : int) => p.[j] * q.[n + n + k - i - j] * r.[i]) 0 n)) (k + 1) n))
        =
        (BCA.bigi predT (fun (i : int) =>
         (BCA.bigi predT (fun (j : int) => - p.[j] * q.[n + k - i - j] * r.[i]) 0 n)) (k + 1) n)
        +
        (BCA.bigi predT (fun (i : int) =>
         (BCA.bigi predT (fun (j : int) => p.[j] * q.[n + n + k - i - j] * r.[i]) 0 n)) (k + 1) n).     
proof.
  rewrite ZModpRing.opprD BCA.sumrN /= ZModpRing.opprK.
  have -> //: (BCA.bigi predT (fun (x : int) =>
          - (BCA.bigi predT (fun (j : int) => p.[j] * q.[n + k - x - j] * r.[x]) 0 n)) (k + 1) n)
         =
         (BCA.bigi predT (fun (i : int) =>
          (BCA.bigi predT (fun (j : int) => - p.[j] * q.[n + k - i - j] * r.[i]) 0 n)) (k + 1) n).
  by rewrite !BCA.big_seq &(BCA.eq_bigr) => i /=; case /mem_range => gek1_i ltn_i; rewrite BCA.sumrN.
qed.

(* Rewritten First Term In Result of eq_pre_mulpA_left Lemma *)
lemma eq_term1_mulpA_left (p q r : poly) (k : int) : 0 <= k => k < n =>
  (BCA.bigi predT (fun (i : int) => 
   (BCA.bigi predT (fun (j : int) => p.[j] * q.[k - i - j] * r.[i]) 0 n)) 0 (k + 1))
  =
  (BCA.bigi predT (fun (i : int) => 
   (BCA.bigi predT (fun (j : int) => p.[j] * q.[k - i - j] * r.[i]) 0 n)) 0 n).
proof.
  move => ge0_k ltn_k.
  rewrite -(ZModpRing.addr0 (BCA.bigi predT (fun (i : int) =>
            (BCA.bigi predT (fun (j : int) => p.[j] * q.[k - i - j] * r.[i]) 0 n)) 0 (k + 1))).
  have <-: (BCA.bigi predT (fun (i : int) =>
         (BCA.bigi predT (fun (j : int) => p.[j] * q.[k - i - j] * r.[i]) 0 n)) (k + 1) n) = zero.
   rewrite BCA.big_seq BCA.big1 //= => i; case /mem_range => gek1_i ltn_i.
    rewrite BCA.big_seq BCA.big1 //= => j; case /mem_range => gek1_j ltn_j.
     have ->: q.[k - i - j] = zero; 2: by rewrite ZModpRing.mulr0 ZModpRing.mul0r. 
      by apply lt0_coeff; smt.  
  by rewrite -BCA.big_cat_int; [rewrite (lez_trans k) 2:lez_addl | rewrite addzC lez_add1r |].
qed.

(* Rewritten Fourth Term In Result of eq_pre_mulpA_left Lemma *)
lemma eq_term4_mulpA_left (p q r : poly) (k : int) : 0 <= k => k < n =>
 (BCA.bigi predT (fun (i : int) =>
  (BCA.bigi predT (fun (j : int) => p.[j] * q.[n + n + k - i - j] * r.[i]) 0 n)) (k + 1) n)
  =
  (BCA.bigi predT (fun (i : int) => 
   (BCA.bigi predT (fun (j : int) => p.[j] * q.[n + n + k - i - j] * r.[i]) 0 n)) 0 n).
proof.
  move => ge0_k ltn_k.
  rewrite -(ZModpRing.add0r ((BCA.bigi predT (fun (i : int) =>
             (BCA.bigi predT (fun (j : int) => p.[j] * q.[n + n + k - i - j] * r.[i]) 0 n)) (k + 1) n))).
  have <-: (BCA.bigi predT (fun (i : int) =>
            (BCA.bigi predT (fun (j : int) =>  p.[j] * q.[n + n + k - i - j] * r.[i]) 0 n)) 0 (k + 1)) = zero.
   rewrite BCA.big_seq BCA.big1 //= => i; case /mem_range => gek1_i ltn_i.
    rewrite BCA.big_seq BCA.big1 //= => j; case /mem_range => gek1_j ltn_j.
     have ->: q.[n + n + k - i - j] = zero; 2: by rewrite ZModpRing.mulr0 ZModpRing.mul0r. 
      by apply gedeg_coeff; smt.  
  by rewrite -BCA.big_cat_int; [rewrite (lez_trans k) 2:lez_addl | rewrite addzC lez_add1r |].
qed.

(* Desired Form of (p * q) * r *)
lemma eq_mulpA_left (p q r : poly) (k : int) : ((p * q) * r).[k] =
  if 0 <= k /\ k < n
  then  (BCA.bigi predT (fun (i : int) => 
        (BCA.bigi predT (fun (j : int) => p.[j] * q.[k - i - j] * r.[i]) 0 n)) 0 n)
        +
        (BCA.bigi predT (fun (i : int) => 
         (BCA.bigi predT (fun (j : int) => - p.[j] * q.[n + k - i - j] * r.[i]) 0 n)) 0 n)
        +
        (BCA.bigi predT (fun (i : int) =>
         (BCA.bigi predT (fun (j : int) => p.[j] * q.[n + n + k - i - j] * r.[i]) 0 n)) 0 n)
  else zero.  
proof.
  rewrite eq_pre_mulpA_left; case (0 <= k /\ k < n) => [[ge0_k ltn_k] |] //.
  rewrite eq_bigterm2_mulpA_left_min ZModpRing.addrA ZModpRing.addrC -ZModpRing.addrA. 
  have ->: ((BCA.bigi predT (fun (i : int) =>
            (BCA.bigi predT (fun (j : int) => - p.[j] * q.[n + k - i - j] * r.[i]) 0 n)) 0 (k + 1))
           +
           (BCA.bigi predT (fun (i : int) =>
            (BCA.bigi predT (fun (j : int) => - p.[j] * q.[n + k - i - j] * r.[i]) 0 n)) (k + 1) n))
           =
           (BCA.bigi predT (fun (i : int) => 
            (BCA.bigi predT (fun (j : int) => - p.[j] * q.[n + k - i - j] * r.[i]) 0 n)) 0 n).
   by rewrite -BCA.big_cat_int; 1,2: smt.
  by rewrite ZModpRing.addrC eq_term1_mulpA_left 3:eq_term4_mulpA_left.
qed.

(* p * (q * r) *)
lemma eq_pre_mulpA_right (p q r : poly) (k : int) : (p * (q * r)).[k] =
  if 0 <= k /\ k < n
  then  (BCA.bigi predT (fun (i : int) => 
        (BCA.bigi predT (fun (j : int) => p.[i] * q.[k - i - j] * r.[j]) 0 n)) 0 (k + 1))
        +
        (BCA.bigi predT (fun (i : int) => 
         (BCA.bigi predT (fun (j : int) => - p.[i] * q.[n + k - i - j] * r.[j]) 0 n)) 0 (k + 1))
        -
        ((BCA.bigi predT (fun (i : int) =>
         (BCA.bigi predT (fun (j : int) => p.[i] * q.[n + k - i - j] * r.[j]) 0 n)) (k + 1) n)
        -
        (BCA.bigi predT (fun (i : int) =>
         (BCA.bigi predT (fun (j : int) => p.[i] * q.[n + n + k - i - j] * r.[j]) 0 n)) (k + 1) n))
  else zero.  
proof.
  rewrite polyMS; case (0 <= k /\ k < n) => [[ge0_k ltn_k] |] //.
    have <-: (BCA.bigi predT (fun (i : int) => p.[i] * (q * r).[k - i]) 0 (k + 1)) 
           =
           (BCA.bigi predT (fun (i : int) =>
            (BCA.bigi predT (fun (j : int) => p.[i] * q.[k - i - j] * r.[j]) 0 n)) 0 (k + 1)) 
           +
           (BCA.bigi predT (fun (i : int) =>
            (BCA.bigi predT (fun (j : int) => - p.[i] * q.[n + k - i - j] * r.[j]) 0 n)) 0 (k + 1)).
    rewrite -BCA.big_split !BCA.big_seq &(BCA.eq_bigr) => /= i; case/mem_range => ge0_i ltk1_i.
    rewrite polyMEr; have ->: 0 <= k - i /\ k - i < n; 1: smt.
    rewrite /= !BCA.mulr_sumr /= BCA.sumrD /= !BCA.big_seq &(BCA.eq_bigr) => i0 /=. 
    case /mem_range => ge0_i0 ltn_i0. rewrite ZModpRing.mulrBr -!ZModpRing.mulrA /#.
   
    have <- //: (BCA.bigi predT (fun (i : int) => - p.[i] * (q * r).[n + k -i]) (k + 1) n)%BCA 
           =
           -(
             (BCA.bigi predT (fun (i : int) =>
              (BCA.bigi predT (fun (j : int) => 
               p.[i] * q.[n + k - i - j] * r.[j]) 0 n)) (k + 1) n) -
             (BCA.bigi predT (fun (i : int) => 
              (BCA.bigi predT (fun (j : int) => 
               p.[i] * q.[n + n + k - i - j] * r.[j]) 0 n)) (k + 1) n)
            ).
  rewrite -BCA.sumrN ZModpRing.eqr_opp BCA.sumrN -BCA.big_split /= !BCA.big_seq &(BCA.eq_bigr) => i /=.
   case /mem_range => gek1_i ltn_i; rewrite polyMEr; have ->: 0 <= n + k - i /\ n + k - i < n; 1: smt.
   rewrite /= !BCA.mulr_sumr BCA.sumrN BCA.sumrD /= !BCA.big_seq &(BCA.eq_bigr) => i0 /=.
    case /mem_range => ge0_i0 ltn_i0; rewrite ZModpRing.mulrBr 2!ZModpRing.mulrA /#.
qed.

(* Rewritten Two Middle Terms In Result of eq_pre_mulpA_right Lemma *)
lemma eq_bigterm2_mulpA_right_min (p q r : poly) (k : int) :
        -
        ((BCA.bigi predT (fun (i : int) =>
         (BCA.bigi predT (fun (j : int) => p.[i] * q.[n + k - i - j] * r.[j]) 0 n)) (k + 1) n)
        -
        (BCA.bigi predT (fun (i : int) =>
         (BCA.bigi predT (fun (j : int) => p.[i] * q.[n + n + k - i - j] * r.[j]) 0 n)) (k + 1) n))
        =
        (BCA.bigi predT (fun (i : int) =>
         (BCA.bigi predT (fun (j : int) => - p.[i] * q.[n + k - i - j] * r.[j]) 0 n)) (k + 1) n)
        +
        (BCA.bigi predT (fun (i : int) =>
         (BCA.bigi predT (fun (j : int) => p.[i] * q.[n + n + k - i - j] * r.[j]) 0 n)) (k + 1) n).     
proof.
  rewrite ZModpRing.opprD BCA.sumrN /= ZModpRing.opprK.
  have -> //: (BCA.bigi predT (fun (x : int) =>
          - (BCA.bigi predT (fun (j : int) => p.[x] * q.[n + k - x - j] * r.[j]) 0 n)) (k + 1) n)
         =
         (BCA.bigi predT (fun (i : int) =>
          (BCA.bigi predT (fun (j : int) => - p.[i] * q.[n + k - i - j] * r.[j]) 0 n)) (k + 1) n).
  by rewrite !BCA.big_seq &(BCA.eq_bigr) => i /=; case /mem_range => gek1_i ltn_i; rewrite BCA.sumrN.
qed.

(* Rewritten First Term In Result of eq_pre_mulpA_right Lemma *)
lemma eq_term1_mulpA_right (p q r : poly) (k : int) : 0 <= k => k < n =>
  (BCA.bigi predT (fun (i : int) => 
   (BCA.bigi predT (fun (j : int) => p.[i] * q.[k - i - j] * r.[j]) 0 n)) 0 (k + 1))
  =
  (BCA.bigi predT (fun (i : int) => 
   (BCA.bigi predT (fun (j : int) => p.[i] * q.[k - i - j] * r.[j]) 0 n)) 0 n).
proof.
  move => ge0_k ltn_k.
  rewrite -(ZModpRing.addr0 (BCA.bigi predT (fun (i : int) =>
            (BCA.bigi predT (fun (j : int) => p.[i] * q.[k - i - j] * r.[j]) 0 n)) 0 (k + 1))).
  have <-: (BCA.bigi predT (fun (i : int) =>
         (BCA.bigi predT (fun (j : int) => p.[i] * q.[k - i - j] * r.[j]) 0 n)) (k + 1) n) = zero.
   rewrite BCA.big_seq BCA.big1 //= => i; case /mem_range => gek1_i ltn_i.
    rewrite BCA.big_seq BCA.big1 //= => j; case /mem_range => gek1_j ltn_j.
     have ->: q.[k - i - j] = zero; 2: by rewrite ZModpRing.mulr0 ZModpRing.mul0r. 
      by apply lt0_coeff; smt.  
  by rewrite -BCA.big_cat_int; [rewrite (lez_trans k) 2:lez_addl | rewrite addzC lez_add1r |].
qed.

(* Rewritten Fourth Term In Result of eq_pre_mulpA_right Lemma *)
lemma eq_term4_mulpA_right (p q r : poly) (k : int) : 0 <= k => k < n =>
 (BCA.bigi predT (fun (i : int) =>
  (BCA.bigi predT (fun (j : int) => p.[i] * q.[n + n + k - i - j] * r.[j]) 0 n)) (k + 1) n)
  =
  (BCA.bigi predT (fun (i : int) => 
   (BCA.bigi predT (fun (j : int) => p.[i] * q.[n + n + k - i - j] * r.[j]) 0 n)) 0 n).
proof.
  move => ge0_k ltn_k.
  rewrite -(ZModpRing.add0r ((BCA.bigi predT (fun (i : int) =>
             (BCA.bigi predT (fun (j : int) => p.[i] * q.[n + n + k - i - j] * r.[j]) 0 n)) (k + 1) n))).
  have <-: (BCA.bigi predT (fun (i : int) =>
            (BCA.bigi predT (fun (j : int) =>  p.[i] * q.[n + n + k - i - j] * r.[j]) 0 n)) 0 (k + 1)) = zero.
   rewrite BCA.big_seq BCA.big1 //= => i; case /mem_range => gek1_i ltn_i.
    rewrite BCA.big_seq BCA.big1 //= => j; case /mem_range => gek1_j ltn_j.
     have ->: q.[n + n + k - i - j] = zero; 2: by rewrite ZModpRing.mulr0 ZModpRing.mul0r. 
      by apply gedeg_coeff; smt.  
  by rewrite -BCA.big_cat_int; [rewrite (lez_trans k) 2:lez_addl | rewrite addzC lez_add1r |].
qed.

(* Desired Form of p * (q * r) *)
lemma eq_mulpA_right (p q r : poly) (k : int) : (p * (q * r)).[k] =
  if 0 <= k /\ k < n
  then  (BCA.bigi predT (fun (i : int) => 
        (BCA.bigi predT (fun (j : int) => p.[i] * q.[k - i - j] * r.[j]) 0 n)) 0 n)
        +
        (BCA.bigi predT (fun (i : int) => 
         (BCA.bigi predT (fun (j : int) => - p.[i] * q.[n + k - i - j] * r.[j]) 0 n)) 0 n)
        +
        (BCA.bigi predT (fun (i : int) =>
         (BCA.bigi predT (fun (j : int) => p.[i] * q.[n + n + k - i - j] * r.[j]) 0 n)) 0 n)
  else zero.  
proof.
  rewrite eq_pre_mulpA_right; case (0 <= k /\ k < n) => [[ge0_k ltn_k] |] //.
  rewrite eq_bigterm2_mulpA_right_min ZModpRing.addrA ZModpRing.addrC -ZModpRing.addrA. 
  have ->: ((BCA.bigi predT (fun (i : int) =>
            (BCA.bigi predT (fun (j : int) => - p.[i] * q.[n + k - i - j] * r.[j]) 0 n)) 0 (k + 1))
           +
           (BCA.bigi predT (fun (i : int) =>
            (BCA.bigi predT (fun (j : int) => - p.[i] * q.[n + k - i - j] * r.[j]) 0 n)) (k + 1) n))
           =
           (BCA.bigi predT (fun (i : int) => 
            (BCA.bigi predT (fun (j : int) => - p.[i] * q.[n + k - i - j] * r.[j]) 0 n)) 0 n).
   by rewrite -BCA.big_cat_int; 1,2: smt.
  by rewrite ZModpRing.addrC eq_term1_mulpA_right 3:eq_term4_mulpA_right.
qed.

(* -- Associativity of Polynomial Multiplication -- *)
lemma mulpA : associative ( * ).
proof.
  move=> p q r; apply: poly_eqP => k ge0_k ltn_k.
  rewrite eq_mulpA_left eq_mulpA_right ge0_k ltn_k /=.
  have ->: (BCA.bigi predT (fun (i : int) =>
            (BCA.bigi predT (fun (j : int) => p.[i] * q.[k - i - j] * r.[j]) 0 n)) 0 n)
           =
           (BCA.bigi predT (fun (i : int) =>
            (BCA.bigi predT (fun (j : int) => p.[j] * q.[k - i - j] * r.[i]) 0 n)) 0 n).
  rewrite BCA.exchange_big /= !BCA.big_seq &(BCA.eq_bigr) => i /=; case /mem_range => ge0_i ltn_i.
   rewrite !BCA.big_seq &(BCA.eq_bigr) => j /=; case /mem_range => ge0_j ltn_j; rewrite /#.

  have ->: (BCA.bigi predT (fun (i : int) =>
            (BCA.bigi predT (fun (j : int) => - p.[i] * q.[n + k - i - j] * r.[j]) 0 n)) 0 n)
           =
           (BCA.bigi predT (fun (i : int) =>
            (BCA.bigi predT (fun (j : int) => - p.[j] * q.[n + k - i - j] * r.[i]) 0 n)) 0 n).
  rewrite BCA.exchange_big /= !BCA.big_seq &(BCA.eq_bigr) => i /=; case /mem_range => ge0_i ltn_i.
   rewrite !BCA.big_seq &(BCA.eq_bigr) => j /=; case /mem_range => ge0_j ltn_j; rewrite /#.

  have -> //: (BCA.bigi predT (fun (i : int) =>
            (BCA.bigi predT (fun (j : int) => p.[i] * q.[n + n + k - i - j] * r.[j]) 0 n)) 0 n)
           =
           (BCA.bigi predT (fun (i : int) =>
            (BCA.bigi predT (fun (j : int) => p.[j] * q.[n + n + k - i - j] * r.[i]) 0 n)) 0 n).
  rewrite BCA.exchange_big /= !BCA.big_seq &(BCA.eq_bigr) => i /=; case /mem_range => ge0_i ltn_i.
   rewrite !BCA.big_seq &(BCA.eq_bigr) => j /=; case /mem_range => ge0_j ltn_j; rewrite /#.
qed.

lemma mul1p : left_id poly1 polyM.
proof.
  move=> p; apply: poly_eqP => c ge0_c ltn_c.
  rewrite polyME ge0_c ltn_c /= (BCA.big_int_recl (n - 1)) //=; 1: rewrite -(lez_add2r 1) /= ge1_n. 
  rewrite polyCE /= ZModpRing.mul1r BCA.big_seq BCA.big1 -1:?addr0 //= 2:ZModpRing.addr0; last first.
   have ->: p.[n + c] = zero; 2: by rewrite ZModpRing.mulr0 ZModpRing.subr0.
    by apply /gedeg_coeff /(lez_trans n); [apply len_deg | rewrite lez_addl].
  move=> i; rewrite mem_range=> -[ge0_i _]; rewrite polyCE.
  by rewrite addz1_neq0 //= 2!ZModpRing.mul0r ZModpRing.subrr.
qed.

lemma mul0p : left_zero poly0 polyM.
proof.
  move=> p; apply/poly_eqP=> c ge0_c ltn_c; rewrite poly0E polyME ge0_c ltn_c /=.
  by rewrite BCA.big1 //= => i _; rewrite poly0E 2!ZModpRing.mul0r ZModpRing.subrr.
qed.

lemma mulpDl: left_distributive polyM polyD.
proof.
  move=> p q r; apply: poly_eqP => c ge0_c ltn_c; rewrite !(polyME, polyDE) ge0_c ltn_c /=.
  by rewrite -BCA.big_split &(BCA.eq_bigr) => /= i _;
             rewrite polyDE 2!ZModpRing.mulrDl ZModpRing.opprD;
             rewrite ZModpRing.addrCA -ZModpRing.addrA ZModpRing.addrCA ZModpRing.addrA.
qed.

lemma onep_neq0 : poly1 <> poly0.
proof.  
  apply/negP => /poly_eqP /(_ 0); rewrite !polyCE ZModpRing.oner_neq0 implybF /=.
  by apply /(ltr_le_trans 1) /ge1_n.
qed.

op unitp (p : poly) = exists (q : poly), (p * q) = poly1.
op polyV (p : poly) = choiceb (fun (q : poly) => p * q = poly1) p.

(* --- Rp is a Commutative Ring --- *)
clone import Ring.ComRing as PolyRing with
    type t <- poly,
    op zeror <- poly0,
    op oner <- poly1,
    op ( + ) <- polyD,
    op [ - ] <- polyN,
    op ( * ) <- polyM,
    op invr <- polyV,
    pred unit <- unitp
  proof *.
  realize addrA     by apply ZPoly.addrA.
  realize addrC     by apply ZPoly.addrC. 
  realize add0r     by apply ZPoly.add0r.  
  realize addNr     by apply ZPoly.addNr. 
  realize mulrA     by apply mulpA. 
  realize mulrC     by apply mulpC.
  realize mul1r     by apply mul1p. 
  realize mulrDl    by apply mulpDl. 
  realize oner_neq0 by apply onep_neq0. 
  realize mulVr     by move=> p ?; rewrite mulrC &(choicebP (fun (q : poly) => p * q = poly1) p).
  realize unitP     by move=> ? y ?; exists y; rewrite mulrC. 
  realize unitout   by move => ?; rewrite negb_exists /= &(choiceb_dfl).

(* --- Iterative Application of Operations on List of Polynomials --- *)
theory BigPoly.
clone include BigComRing with
    type t <- poly,
    pred CR.unit <- unitp,
    op CR.zeror <- poly0,
    op CR.oner <- poly1,
    op CR.( + ) <- polyD,
    op CR.([-]) <- polyN,
    op CR.( * ) <- polyM,
    op CR.invr <- polyV,
    op CR.intmul <- PolyRing.intmul,
    op CR.ofint <- PolyRing.ofint,
    op CR.exp <- PolyRing.exp
  proof CR.*

  rename [theory] "BAdd" as "PCA"
         [theory] "BMul" as "PCM"

  remove abbrev CR.(-)
  remove abbrev CR.(/).

  realize CR.addrA     by apply: PolyRing.addrA.    
  realize CR.addrC     by apply: PolyRing.addrC.   
  realize CR.add0r     by apply: PolyRing.add0r.  
  realize CR.addNr     by apply: PolyRing.addNr. 
  realize CR.oner_neq0 by apply: PolyRing.oner_neq0.
  realize CR.mulrA     by apply: PolyRing.mulrA.
  realize CR.mulrC     by apply: PolyRing.mulrC.
  realize CR.mul1r     by apply: PolyRing.mul1r.
  realize CR.mulrDl    by apply: PolyRing.mulrDl.
  realize CR.mulVr     by apply: PolyRing.mulVr.
  realize CR.unitP     by apply: PolyRing.unitP.
  realize CR.unitout   by apply: PolyRing.unitout.

lemma polysumE ['a] P F s k :
  (PCA.big<:'a> P F s).[k] = BCA.big P (fun i => (F i).[k]) s.
proof.
  elim: s => /= [|x s ih]; first by rewrite poly0E.
  rewrite !BCA.big_cons -ih PCA.big_cons /=.
  by rewrite -polyDE -(fun_if (fun q => q.[k])).
qed.

end BigPoly.

import BigPoly.

(* --- Polynomial Evaluation --- *)
op peval (p : poly) (a : coeff) =
  BCA.bigi predT (fun i => p.[i] * ZModpRing.exp a i) 0 (deg p + 1).

abbrev root p a = peval p a = zero.
